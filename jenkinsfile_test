//Se genera el mapa con la configuración
Map config = [
    //Unos corhcetes {} significan que vas a meter un trozo de código. Como si ejecutases algo dentro del if
    branchType:{
        if (env.GIT_BRANCH_NAME == 'master') {
            return 'MASTER'
                // Se tira de regex para saber como empieza la rama
        }
        else if (env.GIT_BRANCH_NAME ~== 'feature.*') {
            return 'FEAT'
        }
        else if (env.GIT_BRANCH_NAME ~== 'break.*') {
            return 'BREAK'
        }
        else if (env.GIT_BRANCH_NAME ~== 'fix.*') {
            return 'FIX'
        }
        else {
            return 'UKNOWN'
        }
    },
        // Url del repo, https://stackoverflow.com/questions/45937337/jenkins-pipeline-get-repository-url-variable-under-pipeline-script-from-scm
        httpRepoUrl: scm.userRemoteConfigs[0].url,
        githubToken : {
        withCredentials([usernameColonPassword(credentialsId:'idSecretoJenkins', variable : 'GITHUB_TOKEN')]) {
            return $GITHUB_TOKEN
        }
    }
]

def buscarArchivo(String nombre_ms, String expresion)
{
    ls = sh(script: "ls ./${nombre_ms}", returnStdout: true).trim()
    String[] archivos =  ls.split("\\s+");
    String out = "";
    for(int i = 0; i < archivos.length; ++i)
    {
        if(archivos[i].contains(expresion))
        {
            out = archivos[i];
        }
    }
    return out;
}

pipeline{
    agent {
        kubernetes {
            yaml '''
                apiVersion: v1
                kind : Pod
                spec :
                  hostAliases:
                  -ip : "192.168.2.80"
                    hostnames :
                    -"pre.jenkins.com"
                  imagePullSecrets :
                  -name : nexus - pre
                  containers :
                  -name : jnlp
                    image : pre.docker.nexus.com / jnlp - custom : 0.0.0
                  - name : alpine - core
                    image : pre.docker.nexus.com / alpine - core : 0.0.0
                    command :
                    -cat
                    tty : true
            '''
        }
    }
    stages {
        stage('Get next version') {
            steps {
                script {
                    if (isValidBranch()) {
                        String lastTag = lastTag()
                        String nextTag = calculateNextTag(lastTag)
                        createTag(nextTag)
                        }
                    }
                 }
            }
            stage('Build app') {
                //Has de contruir el proyecto de front para que el Dockerfile lo recoja
                steps {
                    script {
                        if (isValidBranch()) {
                        sh npm run dev
                        }
                    }
                }
            }
            stage('Crear Namespaces') {
                steps {
                    script {
                        def kubeconfig = '/ruta/kubeconfig'
                        sh script : "kubectl --kubeconfig=${kubeconfig} create namespace produccion", returnStatus : true
                        sh script : "kubectl --kubeconfig=${kubeconfig} create namespace preproduccion", returnStatus : true
                        }
                    }
                }
            }
            stage('Docker') {
                steps {
                    script {
                        if (isValidBranch()) {
                            String dockerfile = buscarArchivo( app, "Dockerfile")
                            if(dockerfile != "")
                            {
                                sh "docker image build -f ./${app}/${dockerfile} -t ${app} ."
                                sh "docker push ${Dockerfile}"
                            }
                            else
                            {
                                currentBuild.result = "FAILURE"
                                throw new Exception("No existe ningun Dockerfile en el repositorio.")
                            }
                        }
                        else
                        {
                            currentBuild.result = "FAILURE"
                            throw new Exception("El microservicio ${NOMBRE_MS} no existe en el directorio de GitHub.")
                        }
                    }


                        }
                    }
                }
            }
            stage('Helm') {
                //Implementar quí despliegue de Helm
                steps {
                    script {
                        if (isValidBranch()) {
                            if branchType == 'Master'{
                            sh script : "helm --kubeconfig=${kubeconfig} install mi-release mi-chart --namespace=produccion -f values-produccion.yaml"
                            }
                        else {
                            sh script : "helm --kubeconfig=${kubeconfig} install mi-release mi-chart --namespace=preproduccion -f values-preproduccion.yaml"
                        }
                    }
                }
            }
        }
        post {
            always {
                // Limpieza o acciones finales que deben realizarse sin importar el resultado
            }
            success {
                echo "Pipeline completed successfully"
            }
            failure {
                echo "Pipeline failed"
                // Agregar aquí acciones adicionales en caso de que el pipeline falle
            }
        }
}

boolean isValidBranch() { // Triggers
            return config.branchType != 'UKNOWN'
        }

        boolean isFeature() {
            return config.branchType == 'FEAT'
        }

        boolean isBreak() {
            return config.branchType == 'BREAK'
        }

        boolean isFix() {
            return config.branchType == 'FIX'
        }

        boolean isPullRequestToMaster() {
        // Con esto clonamos el repositorio, es lo correcto??¿¿
            checkout([
                        $class: "GitSCM",
            		    branches: [[name: "origin-pull/pull/${GITHUB_PR_TARGET_BRANCH-master}/merge"]],
            			doGenerateSubmoduleConfigurations: false,
            			extensions: [],
            			submoduleCfg: [],
            			userRemoteConfigs: [
            				[
            					credentialsId: "diego",
            					name: "origin-pull",
            					refspec: "+refs/pull/${GITHUB_PR_TARGET_BRANCH-Mmaster}/merge:refs/remotes/origin-pull/pull/${GITHUB_TARGET_BRANCH-master}/merge",
            					url: "git@github.com:repo.git"
            				]
            			]
            		])
            return env.CHANGE_TARGET == 'refs/heads/master'
        }

        String lastTag() {
            /*
              El sh ejecuta sentencias bash
              Obten los tags remotos
            */
            sh('git ls-remote --tags origi')
                //Ordenalos alfanuméricamente para obtener el último
                return sh(script: 'git describe --tags --abbrev=0', stdout : true)
        }

        String calculateNextTag(String lastTag) {
            String nextTag = '0.0.0'
            def tagParts = lastTag.split('\\.')
            def x = tagParts[0] as int
            def y = tagParts[1] as int
            def z = tagParts[2] as int
                //En mi caso, solo si es pull request a master generare la nueva version
                if (env.GITHUB_EVENT_NAME == 'push') {
                    //Esta parte te la dejo a ti, quiero dormir (ten en cuenta si no hay tags en el repo)
                    if (isFeature()) {
                        y++
                    }
                    else if (isBreak()) {
                        x++
                    }
                    else if (isFix()) {
                        z++
                    }
                    nextTag = "$x.$y.$z"
                    return nextTag
                }
        }

        void createTag(String nextTag) {
            echo("Siguiente version calculada: ${nextTag}")
                sh("git tag ${nextTag}")
        }
